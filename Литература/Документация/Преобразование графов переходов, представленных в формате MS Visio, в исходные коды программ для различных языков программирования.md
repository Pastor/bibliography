#Книга #Автоматное-программирование #Языки #SWITCH #UniMod

| Наименование | Автор | Издательство | Год | Дата начала |
|------|:---------|:-----------|:---------|:----------|
|Преобразование графов переходов, представленных в формате MS Visio, в исходные коды программ для различных языков программирования | Канжелев С. Ю., Шалыто А. А. | СПбГУИТМО | 2005 |2023-07-07|

[c.5  ] Изложим основные особенности этого подхода (автоматное программирование). Если традиционное процедурное программирование базируется на терминах "данные" и "процедуры", объектно-ориентированное программирование - на "атрибутах" и "свойствах", а событийное программирование - на "событиях" и "обработчиках событий", то автоматное программирование, как и в теории управления, использует три понятия: "входное воздействие", "состояние" и "выходное воздействие". При этом "состояния" рассматриваются как абстракции и выделяются на этапе проектирования явно. Связь этих понятий осуществляется при построении графов переходов автоматов. Автоматы обычно рассматриваются, как конечные и детерминированные и предназначены для описания поведения (логики) программ.

[c.6  ] В настоящей работе выполнен анализ трех средств, которые поддерживают #SWITCH -технологию: Visio2Switch[7], #UniMod[8, 9], #FSME[10]. Главный недостаток перечисленных средств состоит в том, что в них не предусмотрена настройка получаемого кода под требования конкретного проекта. Исходный год в них генерируется на одном или двух заранее заданных языках.

[c.9  ] Так, в частности, в книге [11] отмечается, что UML-диаграммы состояний строятся только для описания сути происходящих процессов, а вопрос о формальном и изоморфном преобразовании в исходный код даже не обсуждается.

[c.10 ] Visio2Switch. Недостатки:
- исходный код инструмента закрыт;
- фиксированный язык программирования (_С_), на котором генерируется код;
- невозможность настройки создаваемого кода для нужд конкретного проекта;
- ограничения в задании графов переходов. В частности, не предусмотрена возможность вызова автоматов на ребре, не предусмотрен вызов автомата с конкретным событием, не поддерживается операция _XOR_, название входных и выходных переменных должны быть уникальны для всех автоматов в проекте;
- недостаточно полный шаблон. Не предусмотрены графические элементы, обозначающие переходы, условия и действия на которых разделены не знаком "/", а горизонтальной чертой;
- невозможность запуска из командной строки и требование наличия запущенной программы MS Visio.

[c.12 ] #UniMod. Недостатки:
- ограниченность в оформлении графов переходов - не предусмотрено возможности добавления комментариев и картинок;
- возможность применения только в проектах, создаваемых на языке _Java_ и только на платформе _Eclipse_;
- невозможность генерации исходного кода. (В 2005 году была демонстрация генерации кода)

[c.13 ] #FSME. Недостатки:
- несоответствие дизайна получаемых графов переходов общепринятому;
- не предусмотрена возможность дополнительного оформления графов переходов;
- возможность генерации кода лишь на двух языках (_C++_ и _Pyhton_) и отсутствие возможности настройки получаемого кода.

[c.14 ] Поэтому, даже несмотря на теоретическую возможность автоматической генерации кода по графу переходов автомата, фактически, как показывает анализ проектов на http://is.ifmo.ru, кодирование чаще всего происходит вручную. Это снижает надежность построенных программ.


[c.15 ] Нотация графов переходов. #SWITCH

[c.17 ] #Features Переход и [[#^Out-GroupState|групповой]] переход соединяют одно состояние или групповое состояние с другим состоянием. 

[c.21 ] Как отмечалось в работе \[[[#^2|2]]\], автоматная процедура (процедура, реализующая поведение автомата), состоит из одного оператора _switch_. Групповые переходы в этом случае реализуются с помощью дублирования их для всех состояний, содержащихся в группе, к которой данный групповой переход относится.

[c.41 ] Оба анализатора основаны на совместном применении автоматного программирования и #LL(1)-грамматики. Подробно совместное использование #LL(1)-грамматики и #SWITCH -технологии описано в работах \[[[#^4|4]], [[#^5|5]]\]. #Грамматики 

#Литература:

1. <ins>Шалыто А. А., Туккель Н. И.</ins> SWITCH-технология – автоматный подход к созданию программного обеспечения «реактивных» систем //Программирование. 2001. № 5, с.45–62. [web](http://is.ifmo.ru/works/switch/) ([[SWITCH-технология – автоматный подход к созданию программного обеспечения реактивных систем.pdf|PDF]]) ^1
2. <ins>Шалыто А. А., Туккель Н. И.</ins> Реализация автоматов при программировании событийных систем //Программист. 2002. № 4, с.45–62. [web](http://is.ifmo.ru/works/evsys/) ([[Реализация автоматов при программировании событийных систем.pdf|PDF]]) ^2
3. <ins>Шалыто А. А., Наумов Л. А.</ins> Методы объектно-ориентированной реализации реактивных агентов на основе конечных автоматов //Искусственный интеллект. 2004 №4, c.756-762 [web](http://is.ifmo.ru/works/_aut_oop.pdf) ([[Методы объектно-ориентированной реализации реактивных агентов на основе конечных автоматов.pdf|PDF]]) ^3
4. <ins>Штучкин А., Шалыто А. А.</ins> Совместное использование теории построения компиляторов и #SWITCH -технологии (на примере построения калькулятора) [web](http://is.ifmo.ru/projects/calc/) ([[Совместное использование теории построения компиляторов и SWITCH -технологии на примере калькулятора.zip|ZIP]], [[Совместное использование теории построения компиляторов и SWITCH -технологии на примере калькулятора.pdf|PDF]]) ^4
5. <ins>Ковалев А. С., Лукьянов А. П., Шалыто А. А.</ins> Новый метод вычисления булевых формул [web](http://is.ifmo.ru/projects/libgmx/) ([[Новый метод вычисления булевых формул.pdf|PDF]]) ^5

#Выводы 

В \[[[#^1|1]]\] процесс создания программного продукта в случае, когда требуется построить исходный код, описан следующим образом. Весь процесс разбивается на два этапа: первый этап проектирование с описанием переходов автомата и второй этап само программирование которое сводится к формальному преобразованию построенный переходов автомата в исходный код программы. В большинстве случаев этих этапов оказывается мало. Сам построенный блок кода не всегда может жить отдельно от контекста приложения, который обычно включает в себя переменные, функции, классы, системные вызовы. Поэтому дополнительно приходится добавлять логику работы с полученным кодом автомата, а если в программном продукте используются несколько языков программирования - для каждого из языков. Что добавляет сложности в разработке. 

Описана конструкция группового перехода. Смысл его заключается в том, что переход осуществляется исходя из условия накладываемого на группу состояний, т.е. рассчитывается в момент времени состояние (групповое) которое содержит в себе $N$ сгруппированных состояний. ^Out-GroupState

Для каждого генерируемого файла следует задать шаблон. 